use std::env::var;
use anyhow::Result;
// These are generated by the `command` attribute macro
use commands::{
    set_support_channel::SET_SUPPORT_CHANNEL_COMMAND,
    set_command_prefix::SET_COMMAND_PREFIX_COMMAND,
};

use serenity::{
    model::{
        channel::Message,
    },
    prelude::TypeMapKey,
    client::Context,
};

mod commands;
mod db;
mod dm;

#[serenity::framework::standard::macros::group]
#[commands(set_command_prefix, set_support_channel)]
struct ConfigCommandGroup;

struct Handler;

#[serenity::async_trait]
impl serenity::client::EventHandler for Handler {
    // This function is just for creating support threads via DM
    async fn message(&self, ctx: Context, msg: Message) {
        if !msg.is_private() || msg.is_own(&ctx).await { // ignore everything but DMs
            return;
        }
        if let Err(why) = dm::discern_guild_then_create_support_thread(&ctx, &msg).await {
            msg.reply(ctx, format!("Your thread could not be created.\n{:?}", why)).await;
        }
    }

    async fn ready(&self, _: Context, ready: serenity::model::gateway::Ready) {
        println!("{} is connected!", ready.user.name);
    }
}

// This way of passing data to the bot strikes me as odd.
// Basically, the data is massaged into a TypeMap, which as the name implies,
// maps _types_ to arbitrary data.
// I suppose this is a way of enforcing usage of newtypes.

/*
struct BotName;

impl TypeMapKey for BotName{
    type Value = String;
}
*/

pub struct DbPool;

impl TypeMapKey for DbPool {
    type Value = sqlx::postgres::PgPool;
}

// I'm not entirely sure how caching of the prefix works, but it would definitely be ideal for it
// to happen given that this function is otherwise executing on every message received!
//
// This should always be called before any other function here, so handling the case of missing
// guild in db 
async fn get_prefix(ctx: &Context, msg: &Message) -> Option<String> {
    // Prefixes aren't needed for anything in DMs
    if msg.is_private() {
        return None
    }
    let data = ctx.data.read().await;
    let pool = data.get::<DbPool>().unwrap();
    let guild_id = msg.guild_id.unwrap().0 as i64;
    let prefix = sqlx::query!(
        "with new_guild as (
            insert into guilds (id) values ($1)
            on conflict (id) do nothing
            returning command_prefix
        ) select coalesce(
            (select command_prefix from new_guild)
          , (select command_prefix from guilds where id = $1)
        ) command_prefix",
        guild_id
    ).fetch_one(pool).await.unwrap().command_prefix; //panic if it fails I guess
    prefix
}

#[tokio::main]
async fn main() -> Result<()> {
    // Simply include your configuration in a `.env` file
    dotenv::dotenv().ok();
    let token = var("DISCORD_TOKEN").expect("Expected a Discord token in the environment");
    //let bot_name = var("BOT_NAME").expect("Expected env var BOT_NAME");
    let database_url = var("DATABASE_URL").expect("Expected env var DATABASE_URL");
    // It doesn't feel like it matters whether we use `connect` or `connect_lazy`
    let db_pool = sqlx::postgres::PgPoolOptions::new().connect(&database_url).await?;
    let framework = serenity::framework::standard::StandardFramework::new()
        .configure(|c| c.dynamic_prefix(|ctx, msg| Box::pin(get_prefix(ctx, msg))).prefix(""))
        .group(&CONFIGCOMMANDGROUP_GROUP)
        ;
    let mut client =
        serenity::client::Client::builder(&token)
        .event_handler(Handler)
        .framework(framework)
        .await.expect("Err creating client");
    {
        // Insert configuration into the bot
        let mut data = client.data.write().await;
        //data.insert::<BotName>(bot_name);
        data.insert::<DbPool>(db_pool);
    }

    if let Err(why) = client.start().await {
        println!("Client error: {:?}", why);
    }
    Ok(())
}
