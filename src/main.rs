use std::env::var;
use unicode_segmentation::UnicodeSegmentation; //, Graphemes};
use anyhow::Result;
use clap::{Parser, Subcommand};
use const_format::{concatcp, formatcp};

// These are generated by the `command` attribute macro
use commands::{
    set_support_channel::SET_SUPPORT_CHANNEL_COMMAND,
    set_command_prefix::SET_COMMAND_PREFIX_COMMAND,
};

use serenity::{
    builder::CreateApplicationCommands,
    client::Context,
    model::{
        channel::Message,
        gateway,
        id::GuildId,// ChannelId},
        interactions,
        interactions::Interaction,
        interactions::application_command,
    },
    prelude::TypeMapKey,
};

#[derive(Parser)]
#[clap(author, version, about, long_about = None)]
#[clap(propagate_version = true)]
struct Cli {
    #[clap(subcommand)]
    subcommand: Subcommands,
}

#[derive(Subcommand, PartialEq)]
enum Subcommands {
    Bot,
    RegisterSlashCommands,
    UnregisterSlashCommands,
}

type HttpClient = serenity::http::client::Http;

mod commands;
mod db;
mod dm;

#[serenity::framework::standard::macros::group]
#[commands(set_command_prefix, set_support_channel)]
struct ConfigCommandGroup;

struct Handler;

const HELP_MESSAGE: &'static str = formatcp!("\
Hi! My job is to connect you with the administrators of this server!
I can create a _support thread_ that is _private_: only you and the admins can see it it.
Y'all can explicitly invite someone else to the thread by pinging them there.

I support one command for everyone, and one command for administrators

**Everyone commands**:
{everyone_commands}

**Admin commands**:
{admin_commands}
",
everyone_commands = EVERYONE_COMMANDS_DOCS,
admin_commands = ADMIN_COMMANDS_DOCS,
);

const SUPPORT_COMMAND_HELP_USAGE: &'static str = "`/support <thread-title>`";
// This needs to be <= 100 characters, according to Discord API requirements:
// https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure
const SUPPORT_COMMAND_HELP_EXPLANATION: &'static str = "I will create a support thread with your supplied title.";
const SUPPORT_COMMAND_HELP_EXPLANATION_EXTENDED: &'static str = concatcp!(SUPPORT_COMMAND_HELP_EXPLANATION, "\n\t\t(appended to your nickname here, i.e. `your-nick | thread-title`, and truncated to 100 characters)");
const SUPPORT_CHANNEL_COMMAND_HELP_USAGE: &'static str ="`/support_channel <channel>`";
const SUPPORT_CHANNEL_COMMAND_HELP_EXPLANATION: &'static str = "I will start using this channel as the location where I open support threads.";
const EVERYONE_COMMANDS_DOCS: &'static str = concatcp!(
    '\t', SUPPORT_COMMAND_HELP_USAGE, '\t', SUPPORT_COMMAND_HELP_EXPLANATION_EXTENDED,
);
const ADMIN_COMMANDS_DOCS: &'static str = concatcp!(
    '\t', SUPPORT_CHANNEL_COMMAND_HELP_USAGE, '\t', SUPPORT_CHANNEL_COMMAND_HELP_EXPLANATION,
);

#[serenity::async_trait]
impl serenity::client::EventHandler for Handler {
    // This function is just for creating support threads via DM
    async fn message(&self, ctx: Context, msg: Message) {
        if !msg.is_private() || msg.is_own(&ctx) { // ignore everything but DMs
            return;
        }
        if let Err(why) = dm::discern_guild_then_create_support_thread(&ctx, &msg).await {
            msg.reply(ctx, format!("Your thread could not be created.\n{:?}", why)).await;
        }
    }
    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        if let Interaction::ApplicationCommand(command) = interaction {
            // TODO: de-hadouken refactoring
            let reply_content = match command.data.name.as_str() {
                "support" => {
                    match &command.guild_id {
                        None => "You can't use this command from DM".to_string(),
                        Some(guild_id) => {
                            let requester = &command.user;
                            let options = command
                                .data
                                .options
                                .get(0)
                                .expect("Expected thread title")
                                .resolved
                                .as_ref().unwrap(); // Double-check if this is safe (I don't see how requiring it could result in a None option)

                            // Oh yeah, it's Java naming time 8D
                            if let application_command::ApplicationCommandInteractionDataOptionValue::String(title) = options {

                                let title_graphemes = title.graphemes(true);
                                let requester_name = match requester.nick_in(ctx.clone(), guild_id).await {
                                    Some(nick) => nick,
                                    None => requester.tag().split('#').next().unwrap().to_string(),
                                };
                                let processed_title = dm::generate_thread_name(&requester_name, title_graphemes);
                                match fetch_support_channel_id_and_create_thread(ctx.clone(), *guild_id, requester, processed_title).await {
                                    Ok(_) => "Created your support thread!".to_string(),
                                    Err(e) => format!("Failed with {:?}", e),
                                }
                                
                            } else {
                                "Please provide a title for the support thread".to_string()
                            }
                        }
                    }
                },
                "support_channel" => {
                    match &command.guild_id {
                        None => "You can't use this command from DM".to_string(),
                        Some(guild_id) => {
                            let options = command
                                .data
                                .options
                                .get(0)
                                .expect("Expected channel")
                                .resolved
                                .as_ref().unwrap(); // Double-check if this is safe (I don't see how requiring it could result in a None option)

                            // Oh yeah, it's Java naming time 8D
                            if let application_command::ApplicationCommandInteractionDataOptionValue::Channel(channel) = options {
                                let data = ctx.data.read().await;
                                let pool = data.get::<crate::DbPool>().unwrap();
                                match db::update_support_channel_id(&pool, *guild_id, channel.id).await {
                                    Ok(_) => {
                                        match &channel.name {
                                            Some(channel_name) => format!("Successfully set support channel to #{}", &channel_name),
                                            None => format!("Successfully set support channel to <#{}>", &channel.id),
                                        }
                                    }
                                    Err(e) => format!("Failed with {:?}", e),
                                }
                                
                            } else {
                                "Please provide a channel where I should open support threads".to_string()
                            }
                        }
                    }
                }
                "help" => HELP_MESSAGE.to_string(),
                _ => "command not implemented".to_string(),
            };

            command.create_interaction_response(&ctx.http, |response| {
                response
                    .kind(interactions::InteractionResponseType::ChannelMessageWithSource)
                    .interaction_response_data(|message| {
                        message.content(reply_content)
                            .flags(interactions::InteractionApplicationCommandCallbackDataFlags::EPHEMERAL)
                    })
            }).await;
        }
    }

    async fn ready(&self, ctx: Context, ready: gateway::Ready) {
        // let data = ctx.data.read().await;
        // let optional_target_guild_id = data.get::<OptionalTargetGuildId>().unwrap();
        // if let Some(target_guild_id) = optional_target_guild_id {
        //     delete_existing_guild_application_commands(ctx.clone(), *target_guild_id).await;
        //     create_guild_application_commands(ctx.clone(), *target_guild_id).await;
        // } else {
        //     delete_existing_global_application_commands(ctx.clone()).await;
        //     create_global_application_commands(ctx.clone()).await;
        // }
        ctx.set_activity(gateway::Activity::listening("/help")).await;
        println!("{} is connected!", ready.user.name);
    }
}

async fn fetch_support_channel_id_and_create_thread(
    ctx: Context,
    guild_id: GuildId,
    requester: &serenity::model::user::User,
    thread_name: String
) -> Result<()> {
    let data = ctx.data.read().await;
    let pool = data.get::<crate::DbPool>().unwrap();
    match db::get_support_channel_id(pool, guild_id).await? {
        //TODO: factor this type of error out of DmError
        None => Err(crate::dm::DmError::UnconfiguredGuild{guild_id: guild_id}.into()),
        Some(support_channel_id) => {
            // Factor this out if it's intended to be coupled to functionality of
            // create-thread-by-dm
            let thread = support_channel_id.create_private_thread(
                ctx.clone(),
                |thread_builder| thread_builder.name(thread_name).auto_archive_duration(4320)
            ).await?;
            thread.send_message(ctx.clone(), |msg_builder|
                msg_builder.content(serenity::utils::MessageBuilder::new().mention(requester)),
            ).await?;
            Ok(())
        }
    }
}

async fn delete_existing_global_application_commands(client: &HttpClient) {
    for ac in client.get_global_application_commands().await.unwrap() {
        println!("{:?}", ac);
        client.delete_global_application_command(ac.id.into()).await.unwrap();
    }
}

// async fn delete_existing_guild_application_commands(ctx: Context, target_guild_id: GuildId) {
//     for ac in GuildId::get_application_commands(&target_guild_id, &ctx.http).await.unwrap() {
//         println!("{:?}", ac);
//         GuildId::delete_application_command(&target_guild_id, &ctx.http, ac.id).await.unwrap();
//     }
// }

async fn delete_existing_guild_application_commands(client: &HttpClient, target_guild_id: GuildId) {
    // The http client API seems to be designed more for use by the bot client than for use as a library.
    // Taking raw types as args (e.g. u64 rather than GuildId, json::Value instead of builder fn)
    let guild_id: u64 = target_guild_id.into();
    for ac in client.get_guild_application_commands(guild_id).await.unwrap() {
        println!("{:?}", ac);
        client.delete_guild_application_command(guild_id, ac.id.into()).await.unwrap();
    }
}

// async fn create_global_application_commands(ctx: Context) {
//     let commands = application_command::ApplicationCommand::set_global_application_commands(ctx, |commands| build_application_commands(commands)).await;
// }
async fn create_global_application_commands(client: &HttpClient) {
    let commands = build_application_commands();
    // copied invocation from
    // https://docs.rs/serenity/latest/src/serenity/model/guild/guild_id.rs.html#1456-1469
    client.create_global_application_commands(&serenity::json::Value::from(commands.0)).await;
}

fn build_application_commands() -> CreateApplicationCommands {
    let mut commands = CreateApplicationCommands::default();
    commands
        .create_application_command(|command| {
            command
                .name("help")
                .description("Learn how to use this bot")
                .default_permission(true)
        })
        .create_application_command(|command| {
            command
                .name("support")
                .description(SUPPORT_COMMAND_HELP_EXPLANATION)
                .default_permission(true)
                .create_option(|option| {
                    option
                        // Putting a space in the arg to `name` will cause the whole `set_application_commands`
                        // function to silently fail!
                        .name("title")
                        .description("The title for your support thread")
                        .kind(application_command::ApplicationCommandOptionType::String)
                        .required(true)
                })
        })
        .create_application_command(|command| {
            command
                .name("support_channel")
                .description(SUPPORT_CHANNEL_COMMAND_HELP_EXPLANATION)
                .default_permission(false)
                .create_option(|option| {
                    option
                        .name("channel")
                        .description("The channel that will host private support threads")
                        .kind(application_command::ApplicationCommandOptionType::Channel)
                        .required(true)
                })
        });
    commands
}

// async fn create_guild_application_commands(ctx: Context, target_guild_id: GuildId) {
//     let commands = GuildId::set_application_commands(&target_guild_id, &ctx.http, |commands| {
//         commands
//             .create_application_command(|command| {
//                 command
//                     .name("support")
//                     .description("Create a private support thread")
//                     .default_permission(true)
//                     .create_option(|option| {
//                         option
//                             // Putting a space in the arg to `name` will cause the whole `set_application_commands`
//                             // function to silently fail!
//                             .name("title")
//                             .description("The title for your support thread")
//                             .kind(application_command::ApplicationCommandOptionType::String)
//                             .required(true)
//                     })
//             })
//             .create_application_command(|command| {
//                 command
//                     .name("support_channel")
//                     .description("Set the channel that will host private support threads")
//                     .default_permission(false)
//                     .create_option(|option| {
//                         option
//                             .name("channel")
//                             .description("The channel that will host private support threads")
//                             .kind(application_command::ApplicationCommandOptionType::Channel)
//                             .required(true)
//                     })
//             })
//     }).await;
// }

async fn create_guild_application_commands(client: &HttpClient, target_guild_id: GuildId) {
    let commands = build_application_commands();
    // copied invocation from
    // https://docs.rs/serenity/latest/src/serenity/model/guild/guild_id.rs.html#1456-1469
    client.create_guild_application_commands(target_guild_id.into(), &serenity::json::Value::from(commands.0)).await;
}

// This way of passing data to the bot strikes me as odd.
// Basically, the data is massaged into a TypeMap, which as the name implies,
// maps _types_ to arbitrary data.
// I suppose this is a way of enforcing usage of newtypes.

/*
struct BotName;

impl TypeMapKey for BotName{
    type Value = String;
}
*/
struct OptionalTargetGuildId;

impl TypeMapKey for OptionalTargetGuildId{
    type Value = Option<GuildId>;
}

pub struct DbPool;

impl TypeMapKey for DbPool {
    type Value = sqlx::postgres::PgPool;
}

// I'm not entirely sure how caching of the prefix works, but it would definitely be ideal for it
// to happen given that this function is otherwise executing on every message received!
//
// This should always be called before any other function here, so handling the case of missing
// guild in db 
async fn get_prefix(ctx: &Context, msg: &Message) -> Option<String> {
    // Prefixes aren't needed for anything in DMs
    if msg.is_private() {
        return None
    }
    let data = ctx.data.read().await;
    let pool = data.get::<DbPool>().unwrap();
    let guild_id = msg.guild_id.unwrap().0 as i64;
    let prefix = sqlx::query!(
        "with new_guild as (
            insert into guilds (id) values ($1)
            on conflict (id) do nothing
            returning command_prefix
        ) select coalesce(
            (select command_prefix from new_guild)
          , (select command_prefix from guilds where id = $1)
        ) command_prefix",
        guild_id
    ).fetch_one(pool).await.unwrap().command_prefix; //panic if it fails I guess
    prefix
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    // Simply include your configuration in a `.env` file
    dotenv::dotenv().ok();
    let token = var("DISCORD_TOKEN").expect("Expected a Discord token in the environment");
    //let bot_name = var("BOT_NAME").expect("Expected env var BOT_NAME");
    let bot_user_id = var("BOT_USER_ID").expect("Expected env var BOT_USER_ID")
        .parse::<u64>()?;
    let optional_target_guild_id = match var("TARGET_GUILD_ID"){
        Ok(guild_id_str) => {
            Some(guild_id_str.parse::<u64>()?.into())
        }
        Err(_) => None
    };
    match &cli.subcommand {
        Subcommands::Bot => {
            let database_url = var("DATABASE_URL").expect("Expected env var DATABASE_URL");
            // It doesn't feel like it matters whether we use `connect` or `connect_lazy`
            let db_pool = sqlx::postgres::PgPoolOptions::new().connect(&database_url).await?;
            let framework = serenity::framework::standard::StandardFramework::new()
                .configure(|c| c.dynamic_prefix(|ctx, msg| Box::pin(get_prefix(ctx, msg))).prefix(""))
                .group(&CONFIGCOMMANDGROUP_GROUP)
                ;
            let mut client =
                serenity::client::Client::builder(&token, gateway::GatewayIntents::empty())
                .event_handler(Handler)
                .application_id(bot_user_id)
                .framework(framework)
                .await.expect("Err creating client");
            {
                // Insert configuration into the bot
                let mut data = client.data.write().await;
                //data.insert::<BotName>(bot_name);
                data.insert::<DbPool>(db_pool);
                data.insert::<OptionalTargetGuildId>(optional_target_guild_id);
            }

            if let Err(why) = client.start().await {
                println!("Client error: {:?}", why);
            }
        },
        Subcommands::RegisterSlashCommands | Subcommands::UnregisterSlashCommands => {
            let client = HttpClient::new_with_application_id(&token, bot_user_id);
            if let Some(target_guild_id) = optional_target_guild_id {
                delete_existing_guild_application_commands(&client, target_guild_id).await;
                if cli.subcommand == Subcommands::RegisterSlashCommands {
                    create_guild_application_commands(&client, target_guild_id).await;
                }
            } else {
                delete_existing_global_application_commands(&client).await;
                if cli.subcommand == Subcommands::RegisterSlashCommands {
                    create_global_application_commands(&client).await;
                }
            }
        },
    }
    Ok(())
}
